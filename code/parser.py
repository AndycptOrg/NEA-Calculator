"""
Module responsible for parsing the tokens generated by the Lexer/Scanner into an AST
"""

from abc import abstractmethod
from typing import Type

# hackish method
from lexer import tokenize, Token, EOL, OpenBracket, ClosedBracket, Comma, ComparisonOperator, Operator, ConditionalOperator, Equality, NameSpace, Number
from utilities import *

__all__ = ["parse", "ParseError"]
# prevent language BNF from becoming docstring


"""
Language BNF

Parser Rules
<Lines>             ::= <Line>
                      | <Line> <Lines>
                      
<Line>              ::= <Assignment> <EOL>
                      | <Expression> <EOL>
                      | <Statement> <EOL>
                      | <EOL>
                      
<Statement>         ::= <NameSpace> <OpenBracket> <Operands> <ClosedBracket>
                      
<Assignment>        ::= <Assignable> <Equality> <Expression>

<Expression>        ::= <Term>
                      | <Term> <Operator> <Expression>
                      
<Term>              ::= <Number>
                      | <Function>
                      | <NameSpace>
                      | <Operator> <Term>
                      | <BracketedTerm>
                      
<BracketedTerm>     ::= <OpenBracket> <Expression> <ClosedBracket>

<Assignable>        ::= <Function> 
                      | <NameSpace>
                      
<Function>          ::= <NameSpace> <OpenBracket> <Operands> <ClosedBracket>

<Operands>          ::= ε
                      | <Operand>
                      | <Operand> <Comma> <Operands>
                      
<Operand>           ::= <Conditional>
                      | <Inequality>
                      | <Expression>
                      
<Conditional>       ::= <Inequality> <ConditionalOperator> <Inequality>

<Inequality>        ::= <Term> <CompOperator> <Term>
                      | <Term> <CompOperator> <Term> <CompOperator> <Term>

Note to future coders looking into this code
the reason the token lists can be consecutively passed and items retrieved from the list without effecting
the original list when a NotCompatibleException is raised
is because "removal" is getting/indexing the value and reassigning the token variable to the new list slice without the retrieved values,
this slice is a new list reference with the same values from the old list and hence does not affect the original list
"""


class Node(JSONable):
    """
    abstract bass class for all nodes/rule in the expression tree
    """
    @classmethod
    @abstractmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Node', list[Token]]:
        """
        matches the token feed into the rules of the Node
        chain of responsibility pattern
        object factory
        :param statements: statements to be identified
        :raises NotCompatibleException: raised when the token feed does not match the rules of the node
        :param tokens: token Input
        :return: the node and the remaining tokens
        """
        raise NotImplementedError("Take method is not implemented by "+cls.__name__)

    @abstractmethod
    def get_json(self) -> dict:
        """
        serializes object
        returns the node in a JSON format
        :return: "JSON" object
        """
        raise NotImplementedError("JSON method is not implemented by "+type(self).__name__)

    @abstractmethod
    def __eq__(self, other) -> bool:
        """
        determines if 2 Nodes are the same
        :param other: the other node
        :return: if the two nodes have the same properties
        """
        raise NotImplementedError("eq is not implemented by "+type(self).__name__)


class Inequality(Node):
    # Inequality>        ::= <Term> <ComparisonOperator> <Term> | <Term> <ComparisonOperator> <Term> <ComparisonOperator> <Term>
    def __init__(self, term1: 'Term', operator1: ComparisonOperator, term2: 'Term', operator2: ComparisonOperator = None, term3: 'Term' = None):
        self._is_sandwiched = operator2 is not None and term3 is not None
        # if it is not valid/ complete sandwich
        if not self._is_sandwiched and (operator2 is not None or term3 is not None):
            raise ValueError("there must be 3 terms and 2 operators or 2 terms and 1 operator, there must be no in-between")
        self._terms = [term1, term2]
        self._operators = [operator1]
        if self._is_sandwiched:
            self._terms.append(term3)
            self._operators.append(operator2)
        if any(map(lambda a: not isinstance(a, Term), self._terms)) or any(map(lambda a: not isinstance(a, ComparisonOperator), self._operators)):
            raise TypeError("terms and operators must be Term Node and ComparisonOperator Token respectively")

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Inequality', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        term1, tokens = Term.consume(tokens, statements)
        # an inequality must have an operator
        if len(tokens) == 0 or not isinstance(tokens[0], ComparisonOperator):
            raise NotCompatibleException

        operator1, tokens = tokens[0], tokens[1:]
        term2, tokens = Term.consume(tokens, statements)

        # if there is no second operator, that's it
        if len(tokens) == 0 or not isinstance(tokens[0], ComparisonOperator):
            return Inequality(term1, operator1, term2), tokens

        operator2, tokens = tokens[0], tokens[1:]
        term3, tokens = Term.consume(tokens, statements)
        return Inequality(term1, operator1, term2, operator2, term3), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Inequality",
            "Terms": list(map(lambda a: a.get_json(), self._terms)),
            "Comparisons": list(map(lambda a: a.get_json(), self._operators))
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Inequality):
            return False
        return self._terms == other._terms and self._operators == other._operators


class Conditional(Node):
    # <Conditional>       ::= <Inequality> <ConditionalOperator> <Inequality>
    def __init__(self, conditions: list[Inequality]):
        if len(conditions) != 2 or any(map(lambda a: not isinstance(a, Inequality), conditions)):
            raise ValueError("a Conditonal must take 2 conditions/ Inequalities")
        self._conditions = conditions

    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Conditional', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        inequality1, tokens = Inequality.consume(tokens, statements)
        # a conditional must have a conditional operator
        if len(tokens) == 0 or not isinstance(tokens[0], ConditionalOperator):
            raise NotCompatibleException
        inequality2, tokens = Inequality.consume(tokens[1:], statements)
        return Conditional([inequality1, inequality2]), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Conditional",
            "Conditions": list(map(lambda a: a.get_json(), self._conditions))
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Conditional):
            return False
        return self._conditions == other._conditions


class Operand(Node):
    # <Operand>           ::= <Conditional> | <Inequality> | <Expression>
    def __init__(self, operand: 'Expression | Inequality | Conditional'):
        if not isinstance(operand, (Expression, Inequality, Conditional)):
            raise ValueError("operand must be either an Expression, an Inequality, ot a Conditional, not a "+type(operand).__name__)
        self._operand = operand

    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Operand', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        # operand is either a conditional
        try:
            conditional, tokens = Conditional.consume(tokens, statements)
            return Operand(conditional), tokens
        except NotCompatibleException:
            pass
        # or an inequality
        try:
            inequality, tokens = Inequality.consume(tokens, statements)
            return Operand(inequality), tokens
        except NotCompatibleException:
            pass
        # or an expression
        try:
            expression, tokens = Expression.consume(tokens, statements)
            return Operand(expression), tokens
        except NotCompatibleException:
            pass
        # otherwise, it's not an operand
        raise NotCompatibleException

    def get_json(self) -> dict:
        return {
            "Type": "Operand",
            "Operand": self._operand.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Operand):
            return False
        return self._operand == other._operand


class Operands(Node):
    # <Operands>          ::= ε | <Operand> | <Operand> <Comma> <Operands>
    # following are unexpected but permitted behaviours/syntax as defined by the BNF
    # <Operand> <Comma>
    # <Operand> <Comma> <Operand> <Comma>
    # ...
    def __init__(self, *operands: Operand):
        if any(map(lambda a: not isinstance(a, Operand), operands)):
            raise TypeError("operands are supposed to be type Operand")
        self._operands = list(operands)

    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Operands', list[Token]]:
        # if there is no operand to be matched
        try:
            operand, tokens = Operand.consume(tokens, statements)
        except NotCompatibleException:
            return Operands(), tokens
        # if there is nothing to follow up or a comma does not follow, it's done
        if len(tokens) == 0 or not isinstance(tokens[0], Comma):
            return Operands(operand), tokens
        # remove comma token
        tokens = tokens[1:]
        # recursive definition
        operands, tokens = Operands.consume(tokens, statements)
        return Operands(operand, *operands._operands), tokens

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Operands):
            return False
        return self._operands == other._operands

    def get_json(self) -> dict:
        return {
            "Type": "Operands",
            "Operands": list(map(lambda a: a.get_json(), self._operands))
        }


class Function(Node):
    # <Function>          ::= <NameSpace> <OpenBracket> <Operands> <ClosedBracket>
    def __init__(self, name: NameSpace, operands: Operands):
        if not isinstance(name, NameSpace) or not isinstance(operands, Operands):
            raise TypeError("name and operands should be NameSpace and Operands respectively")
        self._name = name
        self._operands = operands

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Function', list[Token]]:
        # if there is no nameSpace in the beginning, there's no chance it's a function
        if len(tokens) == 0 or not isinstance(tokens[0], NameSpace):
            raise NotCompatibleException
        # assign the nameSpace to variable name
        name, tokens = tokens[0], tokens[1:]
        if name.get_json()["Name"] in statements:
            raise NotCompatibleException("function expected, not statement")
        # if there is no openBracket following the name, it's not a function
        if len(tokens) == 0 or not isinstance(tokens[0], OpenBracket):
            raise NotCompatibleException
        operands, tokens = Operands.consume(tokens[1:], statements)
        if len(tokens) == 0 or not isinstance(tokens[0], ClosedBracket):
            raise NotCompatibleException
        return Function(name, operands), tokens[1:]

    def get_json(self) -> dict:
        return {
            "Type": "Function",
            "Name": self._name.get_json(),
            "Operands": self._operands.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Function):
            return False
        return self._name == other._name and self._operands == other._operands


class Assignable(Node):
    # <Assignable>        ::= <Function> | <NameSpace>
    def __init__(self, variable: Function | NameSpace):
        self._variable = variable

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Assignable', list[Token]]:
        # heuristic
        # if the first token is not a NameSpace, it is not an assignable
        # this is because an assignable is either a function or a namespace, both of which start with a namespace token
        if len(tokens) == 0 or not isinstance(tokens[0], NameSpace):
            raise NotCompatibleException
        try:
            func, tokens = Function.consume(tokens, statements)
            return Assignable(func), tokens
        except NotCompatibleException:
            pass
        return Assignable(tokens[0]), tokens[1:]

    def get_json(self) -> dict:
        return {
            "Type": "Assignable",
            "Assignee": self._variable.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Assignable):
            return False
        return self._variable == other._variable


class BracketedTerm(Node):
    # <BracketedTerm>     ::= <OpenBracket> <Expression> <ClosedBracket>
    def __init__(self, expression: 'Expression'):
        if not isinstance(expression, Expression):
            raise TypeError("expression should be an Expression, not "+type(expression).__name__)
        self._expression = expression

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['BracketedTerm', list[Token]]:
        # bracketed term starts with an openbracket
        if len(tokens) == 0 or not isinstance(tokens[0], OpenBracket):
            raise NotCompatibleException
        expression, tokens = Expression.consume(tokens[1:], statements)
        # and ends with a closed bracket
        if len(tokens) == 0 or not isinstance(tokens[0], ClosedBracket):
            raise NotCompatibleException
        return BracketedTerm(expression), tokens[1:]

    def get_json(self) -> dict:
        return {
            "Type": "BracketedTerm",
            "expression": self._expression.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, BracketedTerm):
            return False
        return self._expression == other._expression


class Term(Node):
    # <Term>              ::= <Number> | <Function> | <NameSpace> | <Operator> <Term> | <BracketedTerm>
    def __init__(self, item: Number | Function | NameSpace | BracketedTerm, negated: bool = False):
        if not isinstance(item, (Number, Function, NameSpace, BracketedTerm)):
            raise TypeError("item should not be "+type(item).__name__)
        self._item = item
        self._isNegated = negated

    # noinspection PyTypeChecker,PyPep8Naming
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Term', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        tokenHeadType = type(tokens[0])

        if tokenHeadType == Operator:
            if tokens[0].get_json()["OperatorType"] != "-":
                raise NotCompatibleException("only negating is allowed")
            term, tokens = Term.consume(tokens[1:], statements)
            return Term(term._item, not term._isNegated), tokens

        elif tokenHeadType == Number:
            return Term(tokens[0]), tokens[1:]

        elif tokenHeadType == OpenBracket:
            # try bracketed term, it can't be anything else
            bracketed, tokens = BracketedTerm.consume(tokens, statements)
            return Term(bracketed), tokens

        elif tokenHeadType == NameSpace:
            try:
                func, tokens = Function.consume(tokens, statements)
                return Term(func), tokens
            except NotCompatibleException:
                # if it's not a function, it's a variable
                return Term(tokens[0]), tokens[1:]
        else:
            raise NotCompatibleException

    def get_json(self) -> dict:
        return {
            "Type": ("Negated" if self._isNegated else "")+"Term",
            "Content": self._item.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Term):
            return False
        return self._item == other._item and self._isNegated == other._isNegated


class Expression(Node):
    # <Expression>        ::= <Term> | <Term> <Operator> <Expression>
    def __init__(self, *terms: Term | Operator):
        if any(map(lambda a: not isinstance(a, (Term, Operator)), terms)):
            raise TypeError("terms must be of the type Term node or Operator token")
        self._terms = list(terms)

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Expression', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        term, tokens = Term.consume(tokens, statements)
        # if an operator does not follow, the expression is over/ does not fit the other definition
        if len(tokens) == 0 or not isinstance(tokens[0], Operator):
            return Expression(term), tokens
        operator, tokens = tokens[0], tokens[1:]
        # recursive rule
        expression, tokens = Expression.consume(tokens, statements)
        return Expression(term, operator, *expression._terms), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Expression",
            "TermsAndOperators": list(map(lambda a: a.get_json(), self._terms))
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Expression):
            return False
        return self._terms == other._terms


class Assignment(Node):
    # <Assignment>        ::= <Assignable> <Equality> <Expression>
    def __init__(self, assignee: Assignable, equality: Equality, expression: Expression):
        if (not isinstance(assignee, Assignable) or
            not isinstance(equality, Equality) or
                not isinstance(expression, Expression)):
            raise TypeError("assignee, equality, and expression must be of type Assignable node, Equality token, and Expression node")
        self._assigned = assignee
        self._equals = equality
        self._expression = expression

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=()) -> tuple['Assignment', list[Token]]:
        # heuristic
        if len(tokens) == 0:
            raise NotCompatibleException
        assignable, tokens = Assignable.consume(tokens, statements)
        if len(tokens) == 0 or not isinstance(tokens[0], Equality):
            raise NotCompatibleException
        equals, tokens = tokens[0], tokens[1:]
        expression, tokens = Expression.consume(tokens, statements)
        return Assignment(assignable, equals, expression), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Assignment",
            "Assigned": self._assigned.get_json(),
            "Equality": self._equals.get_json(),
            "Expression": self._expression.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Assignment):
            return False
        return (self._assigned == other._assigned and
                self._equals == other._equals and
                self._expression == other._expression)


class Statement(Node):
    # <Statement>: := <NameSpace> <OpenBracket> <Operands> <ClosedBracket>
    def __init__(self, name: NameSpace, operands: Operands):
        if not isinstance(name, NameSpace) or not isinstance(operands, Operands):
            raise TypeError("name and operands must be of type NameSpace and Operands respectively, not "+type(name).__name__+", "+type(operands).__name__)
        # mutable default values causes pointer issues(ie referencing mess), easy bug origin
        self._name = name
        self._operands = operands

    # noinspection PyTypeChecker
    @classmethod
    def consume(cls, tokens: list[Token], statements=None) -> tuple['Statement', list[Token]]:
        # heuristic
        if len(tokens) < 3 or not isinstance(tokens[0], NameSpace):
            raise NotCompatibleException
        name, tokens = tokens[0], tokens[1:]
        if name.get_json()["Name"] not in statements:
            raise NotCompatibleException
        if not isinstance(tokens[0], OpenBracket):
            raise NotCompatibleException
        tokens = tokens[1:]
        operands, tokens = Operands.consume(tokens, statements)
        if not isinstance(tokens[0], ClosedBracket):
            raise NotCompatibleException
        tokens = tokens[1:]
        return Statement(name, operands), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Statement",
            "Name": self._name.get_json(),
            "Operands": self._operands.get_json()
        }

    # noinspection PyProtectedMember
    def __eq__(self, other) -> bool:
        if not isinstance(other, Statement):
            return False
        return self._name == other._name and self._operands == other._operands


class Line(Node):
    # <Line>              ::= <Assignment> <EOL> | <Expression> <EOL> | <Statement> <EOL> | <EOL>
    def __init__(self, action: Assignment | Expression | Statement | None):
        if not isinstance(action, (Assignment, Expression, Statement, type(None))):
            raise TypeError("action must be an Assignment, Expression, or None")
        self._action = action

    @classmethod
    def consume(cls, tokens: list[Token], statements=None) -> tuple['Line', list[Token]]:
        try:
            action, tokens = Statement.consume(tokens, statements)
        except NotCompatibleException:
            try:
                action, tokens = Assignment.consume(tokens, statements)
            except NotCompatibleException:
                try:
                    action, tokens = Expression.consume(tokens, statements)
                except NotCompatibleException:
                    # placeholder for Nothing (last bit of BNF)
                    action = None
        if len(tokens) == 0 or not isinstance(tokens[0], EOL):
            raise NotCompatibleException
        return Line(action), tokens[1:]

    def get_json(self) -> dict:
        return {
            # recreates last rule
            "Type": ("Empty" if self._action is None else "")+"Line",
            "Action": self._action.get_json() if self._action is not None else "None"
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Line):
            return False
        return self._action == other._action


class Lines(Node):
    # <Lines>             ::= <Line> | <Line> <Lines>
    def __init__(self, *line: Line):
        if any(map(lambda a: not isinstance(a, Line), line)):
            raise NotCompatibleException
        self._lines = list(line)

    @classmethod
    def consume(cls, tokens: list[Token], statements=None) -> tuple['Lines', list[Token]]:
        line, tokens = Line.consume(tokens, statements)
        if len(tokens) == 0:
            return Lines(line), tokens
        try:
            # recursive definition
            lines, tokens = Lines.consume(tokens, statements)
            return Lines(line, *lines._lines), tokens
        except NotCompatibleException:
            return Lines(line), tokens

    def get_json(self) -> dict:
        return {
            "Type": "Lines",
            "Lines": list(map(lambda a: a.get_json(), self._lines))
        }

    # noinspection PyProtectedMember
    def __eq__(self, other):
        if not isinstance(other, Lines):
            return False
        return self._lines == other._lines


@test("Parser")
def parseTest():
    """
    test for parser
    :return: None
    """
    # noinspection PyPep8Naming
    logFile = "../log.txt"
    with open(logFile, "w") as e:
        e.write("Parser Test Results:\n")
        e.write("""
 Test Result |  Type Tested  |       Input       |                    Expected                   |                      Actual                   |
 (Pass/fail) |               |                   |                    Outcome                    |                      Outcome                  |
-------------+---------------+-------------------+-----------------------------------------------+-----------------------------------------------+
"""[1:])

    def tester(inp: str, obj: Type[Node], expectedOutput: Node, expectedRemainder: list[Token], expectedError: Exception = None) -> None:
        """
        Tests if Take method of Node obj will produce the expected result and logs result into the log.txt text file
        :param inp: typical input feed
        :param obj: the node to be taking the tokens
        :param expectedOutput: the node to be expected
        :param expectedRemainder: the trailing tokens after the
        :param expectedError: error expected(if any)
        :return: None
        """
        # noinspection PyShadowingNames
        # ("Settings",) as list of statements for testing purposes

        try:
            result = (outcome := obj.consume(tokenize(inp), ("Settings",))) == (expectedOutput, expectedRemainder) and expectedError is None
            outcome = outcome[0]
            if expectedError is not None:
                outcome = type(expectedError).__name__
        except Exception as e:
            result = e == expectedError
            if not result:
                outcome = type(e).__name__
            else:
                outcome = type(e).__name__
            if expectedError is None:
                result = False
        inp = inp.replace("\n", "\\n")
        inp = f"\"{inp}\""
        expected_output = expectedOutput if expectedError is None else type(expectedError).__name__
        if expectedError is None:
            outcome, *other_lines = dict_beautify(outcome.get_json()).split("\n")
            expected_output, *expected_lines = dict_beautify(expected_output.get_json()).split("\n")
        else:
            other_lines = [" "]
            expected_lines = [" "]
        print(inp, expected_output, outcome)
        print("{:^13}| {:<14}| {:<18}| {:<46}| {:<46}|".format(("Pass" if result else "Fail"), obj.__name__, inp, expected_output, str(outcome)), file=open(logFile, "a"))
        for index in range(max(len(other_lines), len(expected_lines))):
            expected = expected_lines[index] if index < len(expected_lines) else ""
            actual = other_lines[index] if index < len(other_lines) else ""
            print(" "*13+"|"+" "*15+"|"+" "*19+"| {:<46}| {:<46}|".format(expected, actual), file=open(logFile, "a"))
        print("-------------+---------------+-------------------+-----------------------------------------------+-----------------------------------------------+", file=open(logFile, "a"))

        # if expectedError is None:
        #     print(dict_beautify(expectedOutput.get_json()), file=open(logFile, "a"))
    # testing basic terms
    tester("3", Term, Term(Number("3")), [])
    tester("a", Term, Term(NameSpace("a")), [])
    tester("-3", Term, Term(Number("3"), negated=True), [])
    tester("--3", Term, Term(Number("3")), [])
    tester("+3", Term, Node(), [], expectedError=NotCompatibleException("only negating is allowed"))
    # testing Inequality
    tester("4<2", Inequality, Inequality(Term(Number("4")), ComparisonOperator("<"), Term(Number("2"))), [])
    tester("a>=3.4", Inequality, Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4"))), [])
    tester("4==2>o", Inequality,
           Inequality(Term(Number("4")), ComparisonOperator("=="), Term(Number("2")), ComparisonOperator(">"),
                      Term(NameSpace("o"))), [])
    # testing Conditional
    tester("X>3|Y<=2", Conditional, Conditional(
        [Inequality(Term(NameSpace("X")), ComparisonOperator(">"), Term(Number("3"))),
         Inequality(Term(NameSpace("Y")), ComparisonOperator("<="), Term(Number("2")))]), [])
    # testing basic Operand(no expressions)
    tester("a>=3.4", Operand, Operand(Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4")))),
           [])
    tester("X>3|Y<=2", Operand, Operand(Conditional(
        [Inequality(Term(NameSpace("X")), ComparisonOperator(">"), Term(Number("3"))),
         Inequality(Term(NameSpace("Y")), ComparisonOperator("<="), Term(Number("2")))])), [])
    # testing Operands
    tester("", Operands, Operands(), [])
    tester("a>=3.4", Operands,
           Operands(Operand(Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4"))))), [])
    tester("a>=3.4,", Operands,
           Operands(Operand(Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4"))))), [])
    tester("X>3|Y<=2,a>=3.4", Operands, Operands(Operand(Conditional(
        [Inequality(Term(NameSpace("X")), ComparisonOperator(">"), Term(Number("3"))),
         Inequality(Term(NameSpace("Y")), ComparisonOperator("<="), Term(Number("2")))])), Operand(
        Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4"))))), [])
    # tester("X>3|Y<=2,a>=3.4,", Operands, Operands(Operand(Conditional(
    #     [Inequality(Term(NameSpace("X")), ComparisonOperator(">"), Term(Number("3"))),
    #      Inequality(Term(NameSpace("Y")), ComparisonOperator("<="), Term(Number("2")))])), Operand(
    #     Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4"))))), [])
    # testing Function
    tester("func()", Function, Function(NameSpace("func"), Operands()), [])
    tester("func)", Function, Node(), [], expectedError=NotCompatibleException())
    tester("P(a>=3.4)", Function, Function(NameSpace("P"), Operands(
        Operand(Inequality(Term(NameSpace("a")), ComparisonOperator(">="), Term(Number("3.4")))))), [])
    tester("Settings()", Function, Node(), [], expectedError=NotCompatibleException("function expected, not statement"))
    # testing Expression
    tester("1+3", Expression, Expression(Term(Number("1")), Operator("+"), Term(Number("3"))), [])
    tester("1+", Expression, Node(), [], expectedError=NotCompatibleException())
    # tester("func(abba1==-3.4)+3", Expression, Expression(Term(Function(NameSpace("func"), Operands(
    #     Operand(Inequality(Term(NameSpace("abba1")), ComparisonOperator("=="), Term(Number("3.4"), negated=True)))))),
    #                                                      Operator("+"), Term(Number("3"))), [])
    # testing BracketedTerm
    tester("(1+3)", BracketedTerm, BracketedTerm(Expression(Term(Number("1")), Operator("+"), Term(Number("3")))), [])
    # tester("(func(abba1==3.4)+3)", BracketedTerm, BracketedTerm(Expression(Term(Function(NameSpace("func"), Operands(
    #     Operand(Inequality(Term(NameSpace("abba1")), ComparisonOperator("=="), Term(Number("3.4"))))))), Operator("+"),
    #                                                                        Term(Number("3")))), [])
    # testing all Terms
    tester("(1+3)", Term, Term(BracketedTerm(Expression(Term(Number("1")), Operator("+"), Term(Number("3"))))), [])
    # tester("(func(abba1==3.4)+3)", Term, Term(BracketedTerm(Expression(Term(Function(NameSpace("func"), Operands(
    #     Operand(Inequality(Term(NameSpace("abba1")), ComparisonOperator("=="), Term(Number("3.4"))))))), Operator("+"),
    #                                                                    Term(Number("3"))))), [])
    # testing Assignable
    tester("var1", Assignable, Assignable(NameSpace("var1")), [])
    tester("Func1()", Assignable, Assignable(Function(NameSpace("Func1"), Operands())), [])
    tester("Func1(a+2,d)", Assignable, Assignable(Function(NameSpace("Func1"), Operands(
        Operand(Expression(Term(NameSpace("a")), Operator("+"), Term(Number("2")))),
        Operand(Expression(Term(NameSpace("d"))))))), [])
    # testing Assignment
    tester("a=4", Assignment, Assignment(Assignable(NameSpace("a")), Equality("="), Expression(Term(Number("4")))), [])
    tester("f(x)~x+1", Assignment, Assignment(Assignable(Function(NameSpace("f"), Operands(Operand(Expression(Term(NameSpace("x"))))))),
                                              Equality("~"), Expression(Term(NameSpace("x")), Operator("+"), Term(Number("1")))), [])
    # tester("gen(x)~B(x,4/e)", Assignment,
    #        Assignment(Assignable(Function(NameSpace("gen"), Operands(Operand(Expression(Term(NameSpace("x"))))))),
    #                   Equality("~"), Expression(Term(Function(NameSpace("B"),
    #                                                           Operands(Operand(Expression(Term(NameSpace("x")))),
    #                                                                    Operand(
    #                                                                        Expression(Term(Number("4")), Operator("/"),
    #                                                                                   Term(NameSpace("e"))))))))), [])
    # testing Statements
    tester("Settings()", Statement, Statement(NameSpace("Settings"), Operands()), [])
    # Tester("randomFunc()", Statement, Node(), [], expectedError=NotCompatibleException())
    # testing Line
    tester(";", Line, Line(None), [])
    tester("1+3\n", Line, Line(Expression(Term(Number("1")), Operator("+"), Term(Number("3")))), [])
    tester("Settings();", Line, Line(Statement(NameSpace("Settings"), Operands())), [])
    tester("func()\n", Line, Line(Expression(Term(Function(NameSpace("func"), Operands())))), [])
    tester("a=4\n", Line, Line(Assignment(Assignable(NameSpace("a")), Equality("="), Expression(Term(Number("4"))))),
           [])
    # testing Lines
    tester(";", Lines, Lines(Line(None)), [])
    tester(";;", Lines, Lines(Line(None), Line(None)), [])
    tester(";1+3\n;", Lines,
           Lines(Line(None), Line(Expression(Term(Number("1")), Operator("+"), Term(Number("3")))), Line(None)), [])
    tester("", Lines, Node(), [], expectedError=NotCompatibleException())
    tester("l", Lines, Node(), [], expectedError=NotCompatibleException())
    tester("whatis(a,b) = a+b;4/3+", Lines, Lines(Line(Assignment(Assignable(Function(NameSpace("whatis"), Operands(
        Operand(Expression(Term(NameSpace("a")))), Operand(Expression(Term(NameSpace("b"))))))), Equality("="),
                                                                  Expression(Term(NameSpace("a")), Operator("+"),
                                                                             Term(NameSpace("b")))))),
           [Number("4"), Operator("/"), Number("3"), Operator("+")])
    return
    # with open("StatsTest.txt", "r") as f:
    #     for line in f:
    #         print(dictBeautify(parse(scanner(line+";"))[0].JSON()))


class ParseError(Exception):
    pass


def parse(inp: list[Token], statements=()) -> tuple[Node, list[Token]]:
    """
    parses input, if inp does not match language grammar, (None, inp) is returned
    :param inp: the input to be parsed
    :param statements: statements to be identified
    :return: (SyntaxNode, remaining string)
    :raises ParseError: raised when the token sequence is not parsable
    """
    try:
        return Lines.consume(inp, statements)
    except NotCompatibleException:
        raise ParseError("The token sequence cannot be parsed into lines")


if __name__ == "__main__":
    parseTest()

    def tests():
        """
        subroutine that used to visually test the functionality of the parser
        :return:
        """
        # stop it from being run
        quit()

        # noinspection PyPep8Naming
        def testMatching(cls: Type[Node], line: list[Token]):
            """
            gets the first match from a rule in a node class
            (only to be used within file)
            :param cls: the node class to be matched
            :param line: the feed
            :return:
            """
            if __name__ != "__main__":
                return None
            try:
                rootNode = cls.consume(line)
                return rootNode
            except NotCompatibleException:
                return [None]
        # visual tests
        print("matched", *testMatching(Operands, tokenize("3,x,2.4")))
        print("matched", *testMatching(Operands, tokenize("3),<=,2.4")))
        print("matched", *testMatching(Operands, tokenize("3,x),==")))
        print("matched", *testMatching(Inequality, tokenize("pi<x<2.4566666<0")))
        print("matched", *testMatching(Expression, tokenize("4*2+f(5<3)/f(3,3,x)")))
        print("matched", *testMatching(Assignment, tokenize("var=4*2+func(5<3)/f(3,3.1415,x)")))
        print("matched", *testMatching(Expression, tokenize("a*X^2+b*x+c-sqrt(4)+(y-3.2)^2-2\n")))
        print("matched", *testMatching(Line, tokenize("Var=a*X^2+b*x+c-sqrt(4)+(y-3.2)^2-2\n")))
        print("matched", *testMatching(Expression, tokenize("4-(vat(2>4.2<2))^hello(water, 4,6)")))
        print("matched", *testMatching(Line, tokenize("v=4-(vat(2>4.2<2))^hello(water, 4,6)\n")))

        print(dict_beautify(NameSpace.consume("fghgfvh")[0].get_json()))
        print(mystery := tokenize("Var=a*X^2+b*x+c-sqrt(4)+(y-3.2)^2-2\n"))
        # noinspection PyProtectedMember
        print("thikng", Lines.consume(mystery)[0]._lines[0]._action._expression)
        print(dict_beautify(Lines.consume(tokenize("Var=a*X^2+b*x+c-sqrt(4)+(y-3.2)^2-2\n"))[0].get_json()))
        print(dict_beautify(Lines.consume(tokenize("Func();"))[0].get_json()))
        quit()
